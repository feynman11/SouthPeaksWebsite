package main

import (
"context"
	"errors"
	"fmt"
	"time"

	"cloud.google.com/go/firestore"
	"google.golang.org/api/iterator"
)

// Route represents a Strava route submitted by a member
type Route struct {
	ID        string    `firestore:"id,omitempty"`     // Firestore document ID (autogenerated by Firestore, stored here)
	Name      string    `firestore:"name"`             // e.g., "Long Peak Loop"
	URL       string    `firestore:"url"`              // Strava Route URL: https://www.strava.com/routes/...
	Classify  string    `firestore:"classify"`         // "Thursday" or "Saturday"
	SubmittedByUserID string `firestore:"submittedByUserID"` // <--- CHANGED TO STRING
	SubmittedByUserName string `firestore:"submittedByUserName"`
	SubmittedAt time.Time `firestore:"submittedAt"`      // Timestamp of submission
}

const routesCollection = "routes" // Firestore collection name

// CreateRoute adds a new route document to Firestore or updates an existing one
// It now handles both creating new documents (if route.ID is empty)
// or updating existing documents (if route.ID is provided).
func CreateRoute(ctx context.Context, route *Route) error {
	var docRef *firestore.DocumentRef
	var err error

	if route.ID == "" {
		// If ID is empty, Firestore will generate one for new documents.
		docRef, _, err = firestoreClient.Collection(routesCollection).Add(ctx, route)
		if err != nil {
			return fmt.Errorf("failed to create route document: %w", err)
		}
		route.ID = docRef.ID // Store the generated ID back in the struct
	} else {
		// If ID is provided, update the existing document.
		docRef = firestoreClient.Collection(routesCollection).Doc(route.ID)
		_, err = docRef.Set(ctx, route) // Set with the struct overwrites the document
		if err != nil {
			return fmt.Errorf("failed to update route document %s: %w", route.ID, err)
		}
	}
	return nil
}

// GetRouteByID retrieves a single route by its Firestore document ID
func GetRouteByID(ctx context.Context, routeID string) (*Route, error) {
	docRef := firestoreClient.Collection(routesCollection).Doc(routeID)
	docSnap, err := docRef.Get(ctx)
	if err != nil {
		if errors.Is(err, iterator.Done) || docSnap == nil || !docSnap.Exists() {
			return nil, errors.New("route not found")
		}
		return nil, fmt.Errorf("failed to get route document: %w", err)
	}

	var route Route
	if err := docSnap.DataTo(&route); err != nil {
		return nil, fmt.Errorf("failed to convert document to route: %w", err)
	}
	route.ID = docSnap.Ref.ID // Ensure ID is set from document reference
	return &route, nil
}


// GetAllRoutes retrieves all routes from Firestore, ordered by submission time
func GetAllRoutes(ctx context.Context) ([]Route, error) {
	var routes []Route
	iter := firestoreClient.Collection(routesCollection).OrderBy("submittedAt", firestore.Desc).Documents(ctx)
	for {
		doc, err := iter.Next()
		if errors.Is(err, iterator.Done) {
			break
		}
		if err != nil {
			return nil, fmt.Errorf("error iterating over routes: %w", err)
		}

		var route Route
		if err := doc.DataTo(&route); err != nil {
			return nil, fmt.Errorf("error converting document to route: %w", err)
		}
		route.ID = doc.Ref.ID
		routes = append(routes, route)
	}
	return routes, nil
}

// GetUserRoutes retrieves routes submitted by a specific user from Firestore
func GetUserRoutes(ctx context.Context, userID string) ([]Route, error) { // <--- USERID PARAMETER CHANGED TO STRING
	var routes []Route
	iter := firestoreClient.Collection(routesCollection).
		Where("submittedByUserID", "==", userID). // Filter by user ID
		OrderBy("submittedAt", firestore.Desc).
		Documents(ctx)
	for {
		doc, err := iter.Next()
		if errors.Is(err, iterator.Done) {
			break
		}
		if err != nil {
			return nil, fmt.Errorf("error iterating over user routes: %w", err)
		}

		var route Route
		if err := doc.DataTo(&route); err != nil {
			return nil, fmt.Errorf("error converting document to route: %w", err)
		}
		route.ID = doc.Ref.ID
		routes = append(routes, route)
	}
	return routes, nil
}

// DeleteRoute deletes a route document from Firestore
func DeleteRoute(ctx context.Context, routeID string) error {
	_, err := firestoreClient.Collection(routesCollection).Doc(routeID).Delete(ctx)
	if err != nil {
		return fmt.Errorf("failed to delete route document with ID %s: %w", routeID, err)
	}
	return nil
}